# 第7章、简单查询

标签： MySQL是怎样使用的新版

* * *

到现在为止，我们已经掌握了数据库的创建、选择和删除语句，表的创建、修改和删除语句以及一些简单的查询和插入记录的语句。不过这些只不过是一个空架子，对于使用`MySQL`的我们来说，平时使用频率最高的还是查询功能 —— 就是按照我们给定的要求将数据给查出来。从本章开始就要唠叨各种让人眼花缭乱的查询方式了，认真看，仔细看，滴点儿莎普爱思拿抹布擦擦眼继续看！这些东西真的非常重要！

## 准备工作

话说从本章开始的主题是查询数据，所以先得确定一下查哪个表的数据吧，确定了要查哪个表之后该表中先得有数据吧，要不查个毛线呀～ 所以我们先得做点准备工作，也就是确定使用哪个表做示例以及往表里填点数据。

### 用哪个表

为简单起见，我们就复用之前在数据库`xiaohaizi`下边创建的学生信息表`student_info`和学生成绩表`student_score`，你可能有点忘了这两个表长啥样了，我们先把两个表的结构回顾一下：

**学生基本信息表的结构**

    CREATE TABLE student_info (
        number INT PRIMARY KEY,
        name VARCHAR(5),
        sex ENUM('男', '女'),
        id_number CHAR(18),
        department VARCHAR(30),
        major VARCHAR(30),
        enrollment_time DATE,
        UNIQUE KEY (id_number)
    );
    

**学生成绩表的结构**

    CREATE TABLE student_score (
        number INT,
        subject VARCHAR(30),
        score TINYINT,
        PRIMARY KEY (number, subject),
        CONSTRAINT FOREIGN KEY(number) REFERENCES student_info(number)
    );
    

### 为表填入数据

我们给这两个表插入一些数据：

    mysql> INSERT INTO student_info(number, name, sex, id_number, department, major, enrollment_time) VALUES
        ->     (20180101, '杜子腾', '男', '158177199901044792', '计算机学院', '计算机科学与工程', '2018-09-01'),
        ->     (20180102, '杜琦燕', '女', '151008199801178529', '计算机学院', '计算机科学与工程', '2018-09-01'),
        ->     (20180103, '范统', '男', '17156319980116959X', '计算机学院', '软件工程', '2018-09-01'),
        ->     (20180104, '史珍香', '女', '141992199701078600', '计算机学院', '软件工程', '2018-09-01'),
        ->     (20180105, '范剑', '男', '181048199308156368', '航天学院', '飞行器设计', '2018-09-01'),
        ->     (20180106, '朱逸群', '男', '197995199501078445', '航天学院', '电子信息', '2018-09-01');
    Query OK, 6 rows affected (0.01 sec)
    Records: 6  Duplicates: 0  Warnings: 0
    
    mysql> INSERT INTO student_score (number, subject, score) VALUES
        ->     (20180101, '母猪的产后护理', 78),
        ->     (20180101, '论萨达姆的战争准备', 88),
        ->     (20180102, '母猪的产后护理', 100),
        ->     (20180102, '论萨达姆的战争准备', 98),
        ->     (20180103, '母猪的产后护理', 59),
        ->     (20180103, '论萨达姆的战争准备', 61),
        ->     (20180104, '母猪的产后护理', 55),
        ->     (20180104, '论萨达姆的战争准备', 46);
    Query OK, 8 rows affected (0.00 sec)
    Records: 8  Duplicates: 0  Warnings: 0
    
    mysql>
    

现在这两个表中的数据就如下所示了：

**student\_info表**

| number | name | sex | id\_number | department | major | enrollment\_time |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 20180101 | 杜子腾 | 男 | 158177199901044792 | 计算机学院 | 计算机科学与工程 | 2018-09-01 |
| 20180102 | 杜琦燕 | 女 | 151008199801178529 | 计算机学院 | 计算机科学与工程 | 2018-09-01 |
| 20180103 | 范统 | 男 | 17156319980116959X | 计算机学院 | 软件工程 | 2018-09-01 |
| 20180104 | 史珍香 | 女 | 141992199701078600 | 计算机学院 | 软件工程 | 2018-09-01 |
| 20180105 | 范剑 | 男 | 181048200008156368 | 航天学院 | 飞行器设计 | 2018-09-01 |
| 20180106 | 朱逸群 | 男 | 197995199801078445 | 航天学院 | 电子信息 | 2018-09-01 |

**student\_score表**

| number | subject | score |
| :-: | :-: | :-: |
| 20180101 | 母猪的产后护理 | 78 |
| 20180101 | 论萨达姆的战争准备 | 88 |
| 20180102 | 母猪的产后护理 | 100 |
| 20180102 | 论萨达姆的战争准备 | 98 |
| 20180103 | 母猪的产后护理 | 59 |
| 20180103 | 论萨达姆的战争准备 | 61 |
| 20180104 | 母猪的产后护理 | 55 |
| 20180104 | 论萨达姆的战争准备 | 46 |

好了，表的填充工作也已经做完了～ 终于可以开始查询数据了！

## 查询单个列

查看某个表中的某一列的数据的通用格式是这样：

    SELECT 列名 FROM 表名;
    

也就是说把需要查询的列名放到单词`SELECT`后边就好了，比如查看`student_info`表中的`number`列的数据可以这么写：

    mysql> SELECT number FROM student_info;
    +----------+
    | number   |
    +----------+
    | 20180104 |
    | 20180102 |
    | 20180101 |
    | 20180103 |
    | 20180105 |
    | 20180106 |
    +----------+
    6 rows in set (0.00 sec)
    
    mysql>
    

可以看到查询结构中就把所有记录的`number`列都展示了出来，我们有时候也把这个结果称之为`结果集`。

> 小贴士： 你可能发现结果集中的数据并不是按照我们number列值的大小排序的，我们稍后就会说到如何指定结果集中数据的排序方式，稍安勿躁。

### 列的别名

我们也可以为结果集中的列重新定义一个`别名`，命令格式如下：

    SELECT 列名 [AS] 列的别名 FROM 表名;
    

我们看到`AS`被加了个中括号，意味着可有可无，没有`AS`的话，列名和列的别名之间用空白字符隔开就好了。比如我们想给`number`列起个别名，可以使用下边这两种方式之一：

* 方式一

      SELECT number AS 学号 FROM student_info;
      

* 方式二：

      SELECT number 学号 FROM student_info;
      

我们执行一下：

    mysql> SELECT number AS 学号 FROM student_info;
    +----------+
    | 学号     |
    +----------+
    | 20180104 |
    | 20180102 |
    | 20180101 |
    | 20180103 |
    | 20180105 |
    | 20180106 |
    +----------+
    6 rows in set (0.00 sec)
    
    mysql>
    

看到黑框框里的结果集中显示的列名就不再是`number`，而是我们刚刚定义的别名`学号`了。不过需要注意的是：别名只是在本次查询的到的结果集中展示，而不会改变真实表中的列名。下一次查询中你对`number`列取其他的别名也可以，比如这样：

    mysql> SELECT number xuehao FROM student_info;
    +----------+
    | xuehao   |
    +----------+
    | 20180104 |
    | 20180102 |
    | 20180101 |
    | 20180103 |
    | 20180105 |
    | 20180106 |
    +----------+
    6 rows in set (0.00 sec)
    
    mysql>
    

这次输出的列名就是另一个别名`xuehao`了。

## 查询多个列

如果想查询多个列的数据，可以在`SELECT`后边写多个列名，用逗号`,`分隔开就好：

    SELECT 列名1, 列名2, ... 列名n FROM 表名;
    

我们把`SELECT`语句后边跟随的多个列统称为`查询列表`，需要注意的是，查询列表中的列名可以按任意顺序摆放，结果集将按照我们指定的列名顺序显示。比如我们查询`student_info`中的多个列：

    mysql> SELECT number, name, id_number, major FROM student_info;
    +----------+-----------+--------------------+--------------------------+
    | number   | name      | id_number          | major                    |
    +----------+-----------+--------------------+--------------------------+
    | 20180101 | 杜子腾    | 158177199901044792 | 计算机科学与工程         |
    | 20180102 | 杜琦燕    | 151008199801178529 | 计算机科学与工程         |
    | 20180103 | 范统      | 17156319980116959X | 软件工程                 |
    | 20180104 | 史珍香    | 141992199701078600 | 软件工程                 |
    | 20180105 | 范剑      | 181048199308156368 | 飞行器设计               |
    | 20180106 | 朱逸群    | 197995199501078445 | 电子信息                 |
    +----------+-----------+--------------------+--------------------------+
    6 rows in set (0.00 sec)
    
    mysql>
    

本例中的查询列表就是`number，name，id_number，major`，所以结果集中列的顺序就按照这个顺序来显示。当然，我们也可以用别名来输出这些数据：

    mysql> SELECT number AS 学号, name AS 姓名, id_number AS 身份证号, major AS 专业 FROM student_info;
    +----------+-----------+--------------------+--------------------------+
    | 学号     | 姓名      | 身份证号           | 专业                     |
    +----------+-----------+--------------------+--------------------------+
    | 20180101 | 杜子腾    | 158177199901044792 | 计算机科学与工程         |
    | 20180102 | 杜琦燕    | 151008199801178529 | 计算机科学与工程         |
    | 20180103 | 范统      | 17156319980116959X | 软件工程                 |
    | 20180104 | 史珍香    | 141992199701078600 | 软件工程                 |
    | 20180105 | 范剑      | 181048199308156368 | 飞行器设计               |
    | 20180106 | 朱逸群    | 197995199501078445 | 电子信息                 |
    +----------+-----------+--------------------+--------------------------+
    6 rows in set (0.00 sec)
    
    mysql>
    

如果你乐意，同一个列可以在查询列表处重复出现（虽然这通常没什么卵用），比如这样：

    mysql> SELECT number, number, number FROM student_info;
    +----------+----------+----------+
    | number   | number   | number   |
    +----------+----------+----------+
    | 20180104 | 20180104 | 20180104 |
    | 20180102 | 20180102 | 20180102 |
    | 20180101 | 20180101 | 20180101 |
    | 20180103 | 20180103 | 20180103 |
    | 20180105 | 20180105 | 20180105 |
    | 20180106 | 20180106 | 20180106 |
    +----------+----------+----------+
    6 rows in set (0.00 sec)
    
    mysql>
    

## 查询所有列

如果需要把记录中的所有列都查出来，`MySQL`也提供一个省事儿的办法，我们之前也介绍过，就是直接用星号`*`来表示要查询的东西，就像这样：

    SELECT * FROM 表名;
    

这个命令我们之前看过了，就不多唠叨了。不过需要注意的是，除非你确实需要表中的每个列，否则一般最好别使用星号`*`来查询所有列，虽然星号`*`看起来很方便，不用明确列出所需的列，但是查询不需要的列通常会降低性能。

## 查询结果去重

### 去除单列的重复结果

有的时候我们查询某个列的数据时会有一些重复的结果，比如我们查询一下`student_info`表的学院信息：

    mysql> SELECT department FROM student_info;
    +-----------------+
    | department      |
    +-----------------+
    | 计算机学院      |
    | 计算机学院      |
    | 计算机学院      |
    | 计算机学院      |
    | 航天学院        |
    | 航天学院        |
    +-----------------+
    6 rows in set (0.00 sec)
    

因为表里有6条记录，所以给我们返回了6条结果。但是其实好多都是重复的结果，如果我们想去除重复结果的话，可以将`DISTINCT`放在被查询的列前边，就是这样：

    SELECT DISTINCT 列名 FROM 表名;
    

我们对学院信息做一下去重处理：

    mysql> SELECT DISTINCT department FROM student_info;
    +-----------------+
    | department      |
    +-----------------+
    | 计算机学院      |
    | 航天学院        |
    +-----------------+
    2 rows in set (0.00 sec)
    

看到结果集中就只剩下不重复的信息了。

### 去除多列的重复结果

对于查询多列的情况，两条结果重复的意思是：两条结果的每一个列中的值都相同。比如查询学院和专业信息：

    mysql> SELECT department, major FROM student_info;
    +-----------------+--------------------------+
    | department      | major                    |
    +-----------------+--------------------------+
    | 计算机学院      | 计算机科学与工程         |
    | 计算机学院      | 计算机科学与工程         |
    | 计算机学院      | 软件工程                 |
    | 计算机学院      | 软件工程                 |
    | 航天学院        | 飞行器设计               |
    | 航天学院        | 电子信息                 |
    +-----------------+--------------------------+
    6 rows in set (0.00 sec)
    

查询结果中第1、2行记录中的`department`和`major`列都相同，所以这两条记录就是重复的，同理，第3、4行也是重复的。如果我们想对多列查询的结果去重的话，可以直接把`DISTINCT`放在被查询的列的最前边：

    SELECT DISTINCT 列名1, 列名2, ... 列名n  FROM 表名;
    

比如这样：

    mysql> SELECT DISTINCT department, major FROM student_info;
    +-----------------+--------------------------+
    | department      | major                    |
    +-----------------+--------------------------+
    | 计算机学院      | 计算机科学与工程         |
    | 计算机学院      | 软件工程                 |
    | 航天学院        | 飞行器设计               |
    | 航天学院        | 电子信息                 |
    +-----------------+--------------------------+
    4 rows in set (0.00 sec)
    
    mysql>
    

## 限制查询结果条数

有时候查询结果的条数会很多，都显示出来可能会撑爆屏幕～ 所以`MySQL`给我们提供了一种限制结果集中的记录条数的方式，就是在查询语句的末尾使用这样的语法：

    LIMIT 开始行, 限制条数;
    

`开始行`指的是我们想从第几行数据开始查询，`限制条数`是结果集中最多包含多少条记录。

> 小贴士： 在生活中通常都是从1开始计数的，而在计算机中都是从0开始计数的，所以我们平时所说的第1条记录在计算机中算是第0条。比如\`student\_info\`表里的6条记录在计算机中依次表示为：第0条、第1条、第2条、第3条、第4条、第5条。

比如我们查询一下`student_info`表，从第0条记录开始，最多查询2条记录可以这么写：

    mysql> SELECT number, name, id_number, major FROM student_info LIMIT 0, 2;
    +----------+-----------+--------------------+--------------------------+
    | number   | name      | id_number          | major                    |
    +----------+-----------+--------------------+--------------------------+
    | 20180101 | 杜子腾    | 158177199901044792 | 计算机科学与工程         |
    | 20180102 | 杜琦燕    | 151008199801178529 | 计算机科学与工程         |
    +----------+-----------+--------------------+--------------------------+
    2 rows in set (0.00 sec)
    
    mysql>
    

如果指定的`开始行`大于结果中的行数，那查询结果就什么都没有：

    mysql> SELECT number, name, id_number, major FROM student_info LIMIT 6, 2;
    Empty set (0.00 sec)
    
    mysql>
    

如果查询的结果条数不超过`限制条数`，那就可以全部显式出来：

    mysql> SELECT number, name, id_number, major FROM student_info LIMIT 4, 3;
    +----------+-----------+--------------------+-----------------+
    | number   | name      | id_number          | major           |
    +----------+-----------+--------------------+-----------------+
    | 20180105 | 范剑      | 181048199308156368 | 飞行器设计      |
    | 20180106 | 朱逸群    | 197995199501078445 | 电子信息        |
    +----------+-----------+--------------------+-----------------+
    2 rows in set (0.00 sec)
    
    mysql>
    

从第4条开始的记录有两条，`限制条数`为3，所以这两条记录都可以被展示在结果集中。

### 使用默认的开始行

`LIMIT`后边也可以只有一个参数，那这个参数就代表着`限制行数`。也就是说我们可以不指定`开始行`，默认的开始行就是第0行，比如我们可以这么写：

    mysql> SELECT number, name, id_number, major FROM student_info LIMIT 3;
    +----------+-----------+--------------------+--------------------------+
    | number   | name      | id_number          | major                    |
    +----------+-----------+--------------------+--------------------------+
    | 20180101 | 杜子腾    | 158177199901044792 | 计算机科学与工程         |
    | 20180102 | 杜琦燕    | 151008199801178529 | 计算机科学与工程         |
    | 20180103 | 范统      | 17156319980116959X | 软件工程                 |
    +----------+-----------+--------------------+--------------------------+
    3 rows in set (0.00 sec)
    
    mysql>
    

查询结果就展示了从第0条开始的3条记录。

## 对查询结果排序

我们之前查询`number`列的时候得到的记录并不是有序的，这是为什么呢？`MySQL`其实默认会按照这些数据底层存储的顺序来给我们返回数据，但是这些数据可能会经过更新或者删除，如果我们不明确指定按照什么顺序来排序返回结果的话，那我们可以认为该结果中记录的顺序是不确定的。换句话说如果我们想让返回结果中的记录按照某种特定的规则排序，那我们必须显式的指定排序规则。

### 按照单个列的值进行排序

我们可以用下边的语法来指定返回结果的记录按照某一列的值进行排序：

    ORDER BY 列名 ASC|DESC
    

`ASC`和`DESC`指的是排序方向。`ASC`是指按照指定列的值进行由小到大进行排序，也叫做`升序`，`DESC`是指按照指定列的值进行由大到小进行排序，也叫做`降序`，中间的`|`表示这两种方式只能选一个。这回我们用`student_score`表测试一下：

    mysql> SELECT * FROM student_score ORDER BY score ASC;
    +----------+-----------------------------+-------+
    | number   | subject                     | score |
    +----------+-----------------------------+-------+
    | 20180104 | 论萨达姆的战争准备          |    46 |
    | 20180104 | 母猪的产后护理              |    55 |
    | 20180103 | 母猪的产后护理              |    59 |
    | 20180103 | 论萨达姆的战争准备          |    61 |
    | 20180101 | 母猪的产后护理              |    78 |
    | 20180101 | 论萨达姆的战争准备          |    88 |
    | 20180102 | 论萨达姆的战争准备          |    98 |
    | 20180102 | 母猪的产后护理              |   100 |
    +----------+-----------------------------+-------+
    8 rows in set (0.01 sec)
    
    mysql>
    

可以看到输出的记录就是按照成绩由小到大进行排序的。如果省略了 ORDER BY 语句中的排序方向，则默认按照从小到大的顺序进行排序，也就是说`ORDER BY 列名`和`ORDER BY 列名 ASC`的语义是一样的，我们试一下：

    mysql> SELECT * FROM student_score ORDER BY score;
    +----------+-----------------------------+-------+
    | number   | subject                     | score |
    +----------+-----------------------------+-------+
    | 20180104 | 论萨达姆的战争准备          |    46 |
    | 20180104 | 母猪的产后护理              |    55 |
    | 20180103 | 母猪的产后护理              |    59 |
    | 20180103 | 论萨达姆的战争准备          |    61 |
    | 20180101 | 母猪的产后护理              |    78 |
    | 20180101 | 论萨达姆的战争准备          |    88 |
    | 20180102 | 论萨达姆的战争准备          |    98 |
    | 20180102 | 母猪的产后护理              |   100 |
    +----------+-----------------------------+-------+
    8 rows in set (0.01 sec)
    

再看一下从大到小排序的样子：

    mysql> SELECT * FROM student_score ORDER BY score DESC;
    +----------+-----------------------------+-------+
    | number   | subject                     | score |
    +----------+-----------------------------+-------+
    | 20180102 | 母猪的产后护理              |   100 |
    | 20180102 | 论萨达姆的战争准备          |    98 |
    | 20180101 | 论萨达姆的战争准备          |    88 |
    | 20180101 | 母猪的产后护理              |    78 |
    | 20180103 | 论萨达姆的战争准备          |    61 |
    | 20180103 | 母猪的产后护理              |    59 |
    | 20180104 | 母猪的产后护理              |    55 |
    | 20180104 | 论萨达姆的战争准备          |    46 |
    +----------+-----------------------------+-------+
    8 rows in set (0.00 sec)
    
    mysql>
    

### 按照多个列的值进行排序

我们也可以同时指定多个排序的列，多个排序列之间用逗号`,`隔开就好了，就是这样：

    ORDER BY 列1 ASC|DESC, 列2 ASC|DESC ...
    

比如我们想让对`student_score`的查询结果先按照`subjuect`排序，再按照`score`值从大到小的顺序进行排列，可以这么写：

    mysql> SELECT * FROM student_score ORDER BY subject, score DESC;
    +----------+-----------------------------+-------+
    | number   | subject                     | score |
    +----------+-----------------------------+-------+
    | 20180102 | 母猪的产后护理              |   100 |
    | 20180101 | 母猪的产后护理              |    78 |
    | 20180103 | 母猪的产后护理              |    59 |
    | 20180104 | 母猪的产后护理              |    55 |
    | 20180102 | 论萨达姆的战争准备          |    98 |
    | 20180101 | 论萨达姆的战争准备          |    88 |
    | 20180103 | 论萨达姆的战争准备          |    61 |
    | 20180104 | 论萨达姆的战争准备          |    46 |
    +----------+-----------------------------+-------+
    8 rows in set (0.00 sec)
    
    mysql>
    

再提醒一遍，如果不指定排序方向，则默认使用的是`ASC`，也就是从小到大的升序规则。

> 小贴士： 对于数字的排序还是很好理解的，但是字符串怎么排序呢？大写的A和小写的a哪个大哪个小？这个问题涉及到字符串使用的编码方式以及字符串排序规则，我们之后会详细的介绍它们，现在你只需要知道排序的语法就好了。

我们还可以让`ORDER BY`语句和`LIMIT`语句结合使用，不过 ORDER BY 语句必须放在 LIMIT 语句前边，比如这样：

    mysql> SELECT * FROM student_score ORDER BY score LIMIT 1;
    +----------+-----------------------------+-------+
    | number   | subject                     | score |
    +----------+-----------------------------+-------+
    | 20180104 | 论萨达姆的战争准备          |    46 |
    +----------+-----------------------------+-------+
    1 row in set (0.00 sec)
    
    mysql>
    

这样就能找出成绩最低的那条记录了。
